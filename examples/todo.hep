/* OPERTOR PRECEDENCE:

* has priority over +
5 * 6 + 7

  *
  /\
 5  +
    /\
   6  7
   
   is wrong
   
   so rewrite tree to:
   
  +
  /\
 7  *
    /\
   5  6
*/

//ERROR HANDLING: 
//Bail on first error per file when lexxing, report all syntax errors though for undeclared identifier (?)

//FFI:
OpenGl :: #foreign_system_library "OpenGl";
SomeForeignFunction :: (x: float) -> float #foreign OpenGl;

//SCOPING:
#scope_file
// things only scoped to the file here
#scope_export 
// things scoped globally here. this is the default

//SRC FILE LOADING:
#load "filename.jai" rename_type #unshared
rename_type :: (x:string) -> string {
	//this allows renaming of types
}
#load "filename" x => concatenate(x, "t1")  #unshared;
#load "filename" x => concatenate(x, "t2")  #unshared;
/*
because of #unshared these are seperate instances of the imported filename
without unshared they point to the same thing and data
*/

/*
STATIC IF:
static if = regular if requires if boday and else body to be compiled, but static doesnt, only the compile time
branch needs to compile, this is only true syntactally not semantically - so that identifiers dont have to exist instances
none evaluating branch but it has to parse
Can also be used in the middle of structs to conditionally add fields
Same with functions
*/
#if OS_WIN {
//declare one thing
} else {
//declare another thing
}

/*
COMPILER DESIGN:

vid: https://www.youtube.com/watch?v=MnctEW1oL-E&t=432s
(COMPILER DESIGN WITH CASEY)

Parse->Typing->Sizing->Message Send->Message Wait->IR->Run->Machine Code Gen->Exe
-Sizing: Only does stuff for structs to work out size
-- pipe - sizing { per perform_sizing(comp-unit-id) command in q => process each compilation unit and add complete sizings to sizing table (comp-unit id, size  and send  "sizing_complete" (comp unit id) for them, and wait on any incomplete items in typing table (comp-unit id) }
-This has to have cycle breaking in it too, because of infinite loops that can occur
-Enums for example are comp units but so are their members, as they can depend on each other
*/

/*
PRELOADS:
- preload.hep contains primitive types fro compiler even to boot up eg:
see string struct below
*/

//CONTEXTS:
// context gets passed to every function (can exist in a high register) has an allocators etc, context can be pushed 
// for a call herarchy and thus be thread safe 
// https://www.youtube.com/watch?v=ciGQCP6HgqI&t=619s
//https://www.youtube.com/watch?v=SSVHWrYG974
// context in second vid gets renamed to Context_Base and contains TemporaryStorage (linear allocator) and AssertionFailed
// 

//USEFUL:
//cargo run C:\work\other\rust-hephaestus\examples\hello_world.hep
//dbg!(unit.tree.clone());

//STRINGS:
string :: struct {
  count: int; // amount of characters in the string
  data: *u8;  // pointer to the start of the characters
}

to_c_string :: (s: string) -> *u8 {
   result: *u8 = alloc(s.count + 1);
   memcpy(result, s.data, s.count);
   result[s.count] = 0;
}
